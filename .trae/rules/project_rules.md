- Avoid using deprecated methods or properties and packages
- Use Next.js 15 App Router patterns and conventions
  - Organize routes in the app directory
  - Use server components by default
  - Implement proper error boundaries and loading states
  - Follow metadata best practices for SEO

- Follow Tailwind v4 best practices
  - Use custom theme configuration
  - Maintain consistent spacing and color tokens
  - Leverage container queries when needed
  - Keep utility classes organized and maintainable

- Supabase Implementation
  - Use Row Level Security (RLS) policies
  - Implement proper error handling for database operations
  - Follow real-time subscription patterns
  - Use edge functions when applicable

- Prisma Database Management
  - Keep schema models normalized
  - Use migrations for all database changes
  - Implement proper relations between models
  - Use transactions for complex operations

- Clerk Authentication
  - Implement proper middleware protection
  - Use role-based access control
  - Follow security best practices
  - Handle auth state properly

- Shadcn UI Components
  - Use the shadcn/ui for the design system
  - Maintain consistent component styling
  - Use proper component composition
  - Follow accessibility guidelines
  - Keep component variants organized

- TanStack Query Implementation
  - Implement proper caching strategies
  - Use optimistic updates when applicable
  - Handle error states appropriately
  - Follow proper query invalidation patterns

- Stripe Integration
  - Use webhook handlers for payment events
  - Implement proper error handling
  - Follow security best practices
  - Keep payment logic server-side

- General Code Quality
  - Write unit tests for critical functionality
  - Maintain consistent code formatting
  - Use TypeScript strict mode
  - Follow DRY principles
  - Implement proper error logging

- Zod Schema Validation
  - Define strict type schemas
  - Implement proper error handling
  - Use schema composition when needed
  - Follow parsing best practices

- Zustand State Management
  - Create modular stores
  - Implement proper state persistence
  - Use middleware when needed
  - Follow immutability patterns

- TypeScript Strict Rules
  - Enable strict mode in tsconfig.json
  - Use explicit type annotations instead of 'any' or 'unknown'
  - Leverage union types and type guards
  - Implement proper interface definitions
  - Use unknown instead of any for API responses
  - Define proper return types for functions
  - Utilize generic constraints appropriately
  - Enable noImplicitAny compiler option
  - Use type narrowing with type predicates
  - Implement exhaustive type checking
  - Avoid type assertions unless necessary
  - Use readonly modifiers when applicable
